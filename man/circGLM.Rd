% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/circGLM.R
\name{circGLM}
\alias{circGLM}
\title{Fitting Bayesian circular outcome General Linear Models}
\usage{
circGLM(th, X = matrix(nrow = length(th), ncol = 0), conj_prior = rep(0, 3),
  bt_prior_musd = c(mu = 0, sd = 1), starting_values = c(0, 1, rep(0,
  ncol(X))), bwb = rep(0.05, ncol(X)), Q = 10000, burnin = 1000,
  thin = 1, kappaModeEstBandwith = 0.1, CIsize = 0.95, r = 2,
  returnPostSample = TRUE, output = "list", reparametrize = FALSE,
  groupMeanComparisons = TRUE, skipDichSplit = FALSE, centerOnly = FALSE)
}
\arguments{
\item{th}{A vector of angles in radians or degrees, representing the circular
outcome we want to predict. If any value is larger than \code{2 * pi}, the
input is transformed to radians. Otherwise, \code{th} is treated as
radians.}

\item{X}{A matrix of predictors, both continuous (linear) and categorical.
Categorical predictors must be in (0, 1), so that they are treated
separately from the continuous predictors. If not, or if
\cite{skipDichSplit = TRUE}, they will be treated as linear predictors.
continuous.}

\item{conj_prior}{A numeric vector of length 3, containing, in that order,
prior mean direction, prior resultant length, and prior sample size. Used
for the von Mises part of the model, beta_0 and kappa.}

\item{bt_prior_musd}{A numeric vector of length 2, or \code{NA}. If
\code{bt_prior_musd = NA}, a constant prior is used. If it is a numeric
vector of length 2, the first value is the mean, and the second value is
the standard deviation.}

\item{starting_values}{A numeric vector with starting values for the mcmc
sampler. The length of the numeric vector should be 2 plus the number of
columns in X.}

\item{bwb}{A numeric vector, where the length is at least the number of
continuous predictors. This is a tuning parameters used in sampling of
beta. New values are sampled uniformly around the current value of beta
with bounds at \code{bt_cur - bwb} and \code{bt_cur + bwb}. If
\code{reparametrize = TRUE}, bwb corresponds to the bounds around the
reparametrized values.}

\item{Q}{Integer; The number of iterations to perform.}

\item{burnin}{Integer; The number of burnin (warmup) iterations.}

\item{thin}{Integer; The number of parameters sets to sample for each
parameter set that is saved. Can be used to save memory if \code{Q} is
large.}

\item{kappaModeEstBandwith}{Numeric between 0 and 1. The mode of \code{kappa}
is estimated by taking the midpoint of a highest density interval.
Specifically, it is the midpoint of the interval that contains
\code{kappaModeEstBandwith} of the density of the posterior. Reasonable
values are roughly between .005 and .2, although lower values may be
reasonable if Q is large.}

\item{CIsize}{The size of the credible intervals. This is used for all
parameters, whether they use highest density intervals, circular quantiles
or regular quantiles.}

\item{r}{A numeric. \code{r} is the parameter used in the link function
\eqn{g(x, r) = r atan(x)}. If \code{r = 2}, the link function maps the real
line to the full circle. If \code{r < 2} the link functions maps to a
proportion \code{r / 2} of the circle. If \code{r > 2}, the link functions
can reach the same are of the circle multiple times, which is unlikely to
be useful, and should be used with caution.}

\item{returnPostSample}{Logical indicating whether the mcmc sample itself
should be returned. Should only be set to FALSE if there are memory
constraints, as many subsequent analyses rely on the posterior sample
directly.}

\item{output}{A character string, either \code{"list"} or \code{"vector"}. In
most situations, \code{"list"} should be used, which returns a circGLM
object. The \code{"vector"} options is only useful for simulation studies
etc.}

\item{reparametrize}{Logical; If \code{TRUE}, proposals for beta are drawn
uniformly around a reparametrization \code{zt = pi * atan(bt) / 2}, so from
\code{zt_can = runif(1, zt - bwb, zt + bwb)}, which is then transformed
back. Then, the proposals amount to the truncated cauchy pdf. If
\code{FALSE}, proposals for beta are drawn on uniformly around beta, so
from \code{bt_can = runif(1, bt_cur - bwb, bt_cur + bwb)}.}

\item{groupMeanComparisons}{Logical indicating whether mean comparisons in
the form of Bayes Factors and posterior model probabilites should be
computed.}

\item{skipDichSplit}{Logical indicating whether to treat categorical
predictor specially. Usually, \code{skipDichSplit = TRUE} should be used.
In practice, this removes the arbitrary dependence on the labeling of
categorical predictors and ensures that each group has a regression line of
the same shape.}

\item{centerOnly}{Logical; If \code{TRUE}, the continuous predictors are
centered only, not standardized. If \code{FALSE}, the continuous predictors
are standardized.}
}
\value{
A circGLM object, which can be further analyzed with its associated
  \code{\link[plot.circGLM]{plot}} and \code{\link[print.circGLM]{print}}
  functions.
}
\description{
The main function for running Bayesian circular GLMs.
}
\details{
\code{circGLM} performs an mcmc sampler that generates a sample from the
posterior of the intercept \eqn{\beta_0}, regression coefficients
\eqn{\beta}, group mean direction differences \eqn{\delta} and residual
\eqn{\kappa}.

An attempt is made to split the predictor matrix \code{X} into continuous and
categorical predictors. This is done so that the categorical predictors can
be treated differently, which removes the arbitrary dependence on the
labeling of categorical predictors and ensures that each group has a
regression line of the same shape.

The main results obtained are estimates and credible intervals for the
parameters, posterior samples, and Bayes factors for various standard
hypothesis comparisons.

As with all mcmc samplers, convergence must be checked, and tuning parameters
\code{bwb} and \code{reparametrize} can be tweaked if the sampler converges
badly. The circGLM object that is returned contains proportions acceptepted
which can be used to monitor performance.
}
\examples{
dat <- generateCircGLMData()
m   <- circGLM(th = dat[, 1], X = dat[, -1])
print(m)
print(m, type = "all")
plot(m, type = "tracestack")
}
\seealso{
\code{\link{"print.circGLM"}}, \code{\link{"plot.circGLM"}},
  \code{\link{"coef.circGLM"}}, \code{\link{"BF.circGLM"}},
  \code{\link{"residuals.circGLM"}}, \code{\link{"predict.circGLM"}},
  \code{\link{"predict_function.circGLM"}},
  \code{\link{"mcmc_summary.circGLM"}}, \code{\link{"IC_compare.circGLM"}}.
}
